;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Imports
;;

(ns riemann.config
  (:import [java.util HashMap])
  (:require riemann.core
            riemann.transport
            [clojure.java.io   :as io]
            [cheshire.core     :as cheshire]
            [langohr.core      :as l-core]
            [langohr.channel   :as l-channel]
            [langohr.queue     :as l-queue]
            [langohr.consumers :as l-consumers]))

;;
;; End Section: Imports
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Global riemann configuration
;;

(logging/init {:file "riemann.log"})

;;
;; End Section: Global riemann configuration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: User definitions
;; Mostly helper predicates, streams, etc... used
;; when writing policies
;;

; example: (where* (is-node-name "some_name") ...)
(defn is-node-name [node-name]
  (fn [event]
    (= node-name (:node_name event))))

;;
;; End Section: User definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Deployments core administration
;;

(defn queue-message-handler [core]
  (fn [ch {:keys [content-type delivery-tag type] :as meta} ^bytes payload]
    (let [event (cheshire/parse-string (String. payload) true)]
      (riemann.core/stream! core event))))

(def config-lock              (Object.))
(def cores-map                (HashMap.))
(def connection               (atom (l-core/connect)))

(defn start-config! [& children]
  (fn [event]
    (locking config-lock
      (let [config-path   (:config_path event)
            deployment-id (:deployment_id event)]

        ; prepare config cores
        (reset! core      (riemann.core/core))
        (reset! next-core (riemann.core/core))

        ; load configuration files and apply to create new core
        (include config-path)
        (apply!)

        (let [channel    (l-channel/open @connection)
              queue-name (str deployment-id "-riemann")]
          ; subscribe to deployment riemann queue
          (l-queue/declare channel queue-name :exclusive false :durable false :auto-delete true)
          (l-consumers/subscribe channel queue-name (queue-message-handler @core) :auto-ack true)
          ; store core and channel
          (.put cores-map deployment-id {:core @core :channel channel}))))))

(defn stop-config! [& children]
  (fn [event]
    (locking config-lock
      (let [deployment-id (:deployment_id event)
            ; get core instance to stop and remove it from the map
            stopped-core  (.remove cores-map deployment-id)]

        (when stopped-core
          ; close the channel
          (l-core/close (:channel stopped-core))
          ; stop the core instance
          (riemann.core/stop! (:core stopped-core)))))))

;;
;; End Section: Deployments core administration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Management core configuration
;;

(tcp-server {:host "0.0.0.0" :port 5555})

(periodically-expire 5)

(let [index (index)]
  (streams
    (default :ttl 60 index)
    (where (and (service "cloudify.configuration")
                (state "start"))
      (start-config!))
    (where (and (service "cloudify.configuration")
                (state "stop"))
      (stop-config!))))

;;
;; End Section: Management core configuration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
